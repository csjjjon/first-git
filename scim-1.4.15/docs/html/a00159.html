<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>scim: SignalSlot</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">scim
   &#160;<span id="projectnumber">1.4.15</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a00159.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle">
<div class="title">SignalSlot</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00004.html">scim::BoundSlot0_1&lt; R, P1 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a slot taking one argument into a slot taking no arguments.  <a href="a00004.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00005.html">scim::BoundSlot1_2&lt; R, P1, P2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a slot taking two arguments into a slot taking one argument.  <a href="a00005.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html">scim::BoundSlot2_3&lt; R, P1, P2, P3 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a slot taking three arguments into a slot taking two arguments.  <a href="a00006.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html">scim::BoundSlot3_4&lt; R, P1, P2, P3, P4 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a slot taking four arguments into a slot taking three arguments.  <a href="a00007.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00008.html">scim::BoundSlot4_5&lt; R, P1, P2, P3, P4, P5 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a slot taking five arguments into a slot taking four arguments.  <a href="a00008.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html">scim::BoundSlot5_6&lt; R, P1, P2, P3, P4, P5, P6 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a slot taking six arguments into a slot taking five arguments.  <a href="a00009.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00065.html">scim::Node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for classes managing slots.  <a href="a00065.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html">scim::Connection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A signal connection class.  <a href="a00017.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00103.html">scim::SlotNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A node class for managing slots connected to <a class="el" href="a00073.html" title="Base class for the C++ signal interface. ">scim::Signal</a>'s.  <a href="a00103.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html">scim::DefaultMarshal&lt; R &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html">scim::DefaultMarshal&lt; bool &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00073.html">scim::Signal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for the C++ signal interface.  <a href="a00073.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00074.html">scim::Signal0&lt; R, Marshal &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template for a signal passing no arguments and returning a value of type R.  <a href="a00074.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00075.html">scim::Signal0&lt; void, IgnoreMarshal &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00076.html">scim::Signal1&lt; R, P1, Marshal &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template for a signal passing one argument of type P1 and returning a value of type R.  <a href="a00076.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00077.html">scim::Signal1&lt; void, P1, IgnoreMarshal &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00078.html">scim::Signal2&lt; R, P1, P2, Marshal &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template for a signal passing two arguments of type P1 and P2, and returning a value of type R.  <a href="a00078.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00079.html">scim::Signal2&lt; void, P1, P2, IgnoreMarshal &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00080.html">scim::Signal3&lt; R, P1, P2, P3, Marshal &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template for a signal passing three arguments of type P1, P2 and P3, and returning a value of type R.  <a href="a00080.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00081.html">scim::Signal3&lt; void, P1, P2, P3, IgnoreMarshal &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00082.html">scim::Signal4&lt; R, P1, P2, P3, P4, Marshal &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template for a signal passing four arguments of type P1, P2, P3 and P4, and returning a value of type R.  <a href="a00082.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00083.html">scim::Signal4&lt; void, P1, P2, P3, P4, IgnoreMarshal &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00084.html">scim::Signal5&lt; R, P1, P2, P3, P4, P5, Marshal &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template for a signal passing five arguments of type P1, P2, P3, P4 and P5, and returning a value of type R.  <a href="a00084.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00085.html">scim::Signal5&lt; void, P1, P2, P3, P4, P5, IgnoreMarshal &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00086.html">scim::Signal6&lt; R, P1, P2, P3, P4, P5, P6, Marshal &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template for a signal passing six arguments of type P1, P2, P3, P4, P5 and P6, and returning a value of type R.  <a href="a00086.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00087.html">scim::Signal6&lt; void, P1, P2, P3, P4, P5, P6, IgnoreMarshal &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00095.html">scim::Slot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for slots that can connect to scim::Signals.  <a href="a00095.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00096.html">scim::Slot0&lt; R &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class template for slots passing no arguments and returning a value of type R.  <a href="a00096.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html">scim::FunctionSlot0&lt; R &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A slot template for static functions taking no arguments and returning a value of type R.  <a href="a00035.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00056.html">scim::MethodSlot0&lt; T, R &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A slot template for methods in a class of type T taking no arguments and returning a value of type R.  <a href="a00056.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00088.html">scim::SignalSlot0&lt; T, R &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00097.html">scim::Slot1&lt; R, P1 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class template for slots passing one argument of type P1 and returning a value of type R.  <a href="a00097.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html">scim::FunctionSlot1&lt; R, P1 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A slot template for static functions taking one argument of type P1 and returning a value of type R.  <a href="a00036.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html">scim::MethodSlot1&lt; T, R, P1 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A slot template for methods in a class of type T taking one argument of type P1 and returning a value of type R.  <a href="a00057.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00089.html">scim::SignalSlot1&lt; T, R, P1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00098.html">scim::Slot2&lt; R, P1, P2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class template for slots passing two arguments of type P1 and P2, and returning a value of type R.  <a href="a00098.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html">scim::FunctionSlot2&lt; R, P1, P2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A slot template for static functions taking two arguments of type P1 and P2, and returning a value of type R.  <a href="a00037.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00058.html">scim::MethodSlot2&lt; T, R, P1, P2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A slot template for methods in a class of type T taking two arguments of type P1 and P2, and returning a value of type R.  <a href="a00058.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html">scim::SignalSlot2&lt; T, R, P1, P2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00099.html">scim::Slot3&lt; R, P1, P2, P3 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class template for slots passing three arguments of type P1, P2 and P3, and returning a value of type R.  <a href="a00099.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00038.html">scim::FunctionSlot3&lt; R, P1, P2, P3 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A slot template for static functions taking three arguments of type P1, P2 and P3, and returning a value of type R.  <a href="a00038.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00059.html">scim::MethodSlot3&lt; T, R, P1, P2, P3 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A slot template for methods in a class of type T taking three arguments of type P1, P2 and P3, and returning a value of type R.  <a href="a00059.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00091.html">scim::SignalSlot3&lt; T, R, P1, P2, P3 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00100.html">scim::Slot4&lt; R, P1, P2, P3, P4 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class template for slots passing four arguments of type P1, P2, P3 and P4, and returning a value of type R.  <a href="a00100.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00039.html">scim::FunctionSlot4&lt; R, P1, P2, P3, P4 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A slot template for static functions taking four arguments of type P1, P2, P3 and P4, and returning a value of type R.  <a href="a00039.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00060.html">scim::MethodSlot4&lt; T, R, P1, P2, P3, P4 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A slot template for methods in a class of type T taking four arguments of type P1, P2, P3 and P4, and returning a value of type R.  <a href="a00060.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00092.html">scim::SignalSlot4&lt; T, R, P1, P2, P3, P4 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00101.html">scim::Slot5&lt; R, P1, P2, P3, P4, P5 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class template for slots passing five arguments of type P1, P2, P3, P4 and P5, and returning a value of type R.  <a href="a00101.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00040.html">scim::FunctionSlot5&lt; R, P1, P2, P3, P4, P5 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A slot template for static functions taking five arguments of type P1, P2, P3, P4 and P5, and returning a value of type R.  <a href="a00040.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00061.html">scim::MethodSlot5&lt; T, R, P1, P2, P3, P4, P5 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A slot template for methods in a class of type T taking five arguments of type P1, P2, P3, P4 and P5, and returning a value of type R.  <a href="a00061.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00093.html">scim::SignalSlot5&lt; T, R, P1, P2, P3, P4, P5 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00102.html">scim::Slot6&lt; R, P1, P2, P3, P4, P5, P6 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class template for slots passing six arguments of type P1, P2, P3, P4, P5 and P6, and returning a value of type R.  <a href="a00102.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00041.html">scim::FunctionSlot6&lt; R, P1, P2, P3, P4, P5, P6 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A slot template for static functions taking six arguments of type P1, P2, P3, P4, P5 and P6, and returning a value of type R.  <a href="a00041.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html">scim::MethodSlot6&lt; T, R, P1, P2, P3, P4, P5, P6 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A slot template for methods in a class of type T taking six arguments of type P1, P2, P3, P4, P5 and P6, and returning a value of type R.  <a href="a00062.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00094.html">scim::SignalSlot6&lt; T, R, P1, P2, P3, P4, P5, P6 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Bind functions returning a new BoundSlot.</h2></td></tr>
<tr class="memitem:gab6dcccafea2fb2ef5c514269f0100482"><td class="memTemplParams" colspan="2">template&lt;typename R , typename P1 &gt; </td></tr>
<tr class="memitem:gab6dcccafea2fb2ef5c514269f0100482"><td class="memTemplItemLeft" align="right" valign="top">Slot0&lt; R &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00159.html#gab6dcccafea2fb2ef5c514269f0100482">scim::bind</a> (Slot1&lt; R, P1 &gt; *s, P1 p1)</td></tr>
<tr class="separator:gab6dcccafea2fb2ef5c514269f0100482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81772fbc92c59e8e2569bc646a4024a0"><td class="memTemplParams" colspan="2">template&lt;typename R , typename P1 , typename P2 &gt; </td></tr>
<tr class="memitem:ga81772fbc92c59e8e2569bc646a4024a0"><td class="memTemplItemLeft" align="right" valign="top">Slot1&lt; R, P1 &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00159.html#ga81772fbc92c59e8e2569bc646a4024a0">scim::bind</a> (Slot2&lt; R, P1, P2 &gt; *s, P2 p2)</td></tr>
<tr class="separator:ga81772fbc92c59e8e2569bc646a4024a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2380df642d6efaa8aa728c1930d64a3"><td class="memTemplParams" colspan="2">template&lt;typename R , typename P1 , typename P2 , typename P3 &gt; </td></tr>
<tr class="memitem:gac2380df642d6efaa8aa728c1930d64a3"><td class="memTemplItemLeft" align="right" valign="top">Slot2&lt; R, P1, P2 &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00159.html#gac2380df642d6efaa8aa728c1930d64a3">scim::bind</a> (Slot3&lt; R, P1, P2, P3 &gt; *s, P3 p3)</td></tr>
<tr class="separator:gac2380df642d6efaa8aa728c1930d64a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab28fb1b03488cdaf7917019284bf571e"><td class="memTemplParams" colspan="2">template&lt;typename R , typename P1 , typename P2 , typename P3 , typename P4 &gt; </td></tr>
<tr class="memitem:gab28fb1b03488cdaf7917019284bf571e"><td class="memTemplItemLeft" align="right" valign="top">Slot3&lt; R, P1, P2, P3 &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00159.html#gab28fb1b03488cdaf7917019284bf571e">scim::bind</a> (Slot4&lt; R, P1, P2, P3, P4 &gt; *s, P4 p4)</td></tr>
<tr class="separator:gab28fb1b03488cdaf7917019284bf571e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab739be9d680167831b4ae12c32ac2b73"><td class="memTemplParams" colspan="2">template&lt;typename R , typename P1 , typename P2 , typename P3 , typename P4 , typename P5 &gt; </td></tr>
<tr class="memitem:gab739be9d680167831b4ae12c32ac2b73"><td class="memTemplItemLeft" align="right" valign="top">Slot4&lt; R, P1, P2, P3, P4 &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00159.html#gab739be9d680167831b4ae12c32ac2b73">scim::bind</a> (Slot5&lt; R, P1, P2, P3, P4, P5 &gt; *s, P5 p5)</td></tr>
<tr class="separator:gab739be9d680167831b4ae12c32ac2b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa885cc0b753b1b2425a9fdf657489a80"><td class="memTemplParams" colspan="2">template&lt;typename R , typename P1 , typename P2 , typename P3 , typename P4 , typename P5 , typename P6 &gt; </td></tr>
<tr class="memitem:gaa885cc0b753b1b2425a9fdf657489a80"><td class="memTemplItemLeft" align="right" valign="top">Slot5&lt; R, P1, P2, P3, P4, P5 &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00159.html#gaa885cc0b753b1b2425a9fdf657489a80">scim::bind</a> (Slot6&lt; R, P1, P2, P3, P4, P5, P6 &gt; *s, P6 p6)</td></tr>
<tr class="separator:gaa885cc0b753b1b2425a9fdf657489a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Slot functions returning a new slot</h2></td></tr>
<tr class="memitem:ga427440baa70c0064d62297ab75e288c0"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:ga427440baa70c0064d62297ab75e288c0"><td class="memTemplItemLeft" align="right" valign="top">Slot0&lt; R &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00159.html#ga427440baa70c0064d62297ab75e288c0">scim::slot</a> (R(*function)())</td></tr>
<tr class="separator:ga427440baa70c0064d62297ab75e288c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab542dd0c8878b9c550ef8a1dd59fda2e"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename R &gt; </td></tr>
<tr class="memitem:gab542dd0c8878b9c550ef8a1dd59fda2e"><td class="memTemplItemLeft" align="right" valign="top">Slot0&lt; R &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00159.html#gab542dd0c8878b9c550ef8a1dd59fda2e">scim::slot</a> (T1 *&amp;object, R(T2::*function)())</td></tr>
<tr class="separator:gab542dd0c8878b9c550ef8a1dd59fda2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c11533f9ddcce825b5abcd1c4e959c2"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename R &gt; </td></tr>
<tr class="memitem:ga8c11533f9ddcce825b5abcd1c4e959c2"><td class="memTemplItemLeft" align="right" valign="top">Slot0&lt; R &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00159.html#ga8c11533f9ddcce825b5abcd1c4e959c2">scim::slot</a> (T1 *const &amp;object, R(T2::*function)())</td></tr>
<tr class="separator:ga8c11533f9ddcce825b5abcd1c4e959c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef2807b9ee3148787275b46a85648b9e"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename R &gt; </td></tr>
<tr class="memitem:gaef2807b9ee3148787275b46a85648b9e"><td class="memTemplItemLeft" align="right" valign="top">Slot0&lt; R &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00159.html#gaef2807b9ee3148787275b46a85648b9e">scim::slot</a> (T1 &amp;object, R(T2::*function)())</td></tr>
<tr class="separator:gaef2807b9ee3148787275b46a85648b9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa26187744e103060a603f03da82b3a3"><td class="memTemplParams" colspan="2">template&lt;typename R , typename P1 &gt; </td></tr>
<tr class="memitem:gafa26187744e103060a603f03da82b3a3"><td class="memTemplItemLeft" align="right" valign="top">Slot1&lt; R, P1 &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00159.html#gafa26187744e103060a603f03da82b3a3">scim::slot</a> (R(*function)(P1))</td></tr>
<tr class="separator:gafa26187744e103060a603f03da82b3a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac90c6bea00e1c6fdf9e39b360ccfa81c"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename R , typename P1 &gt; </td></tr>
<tr class="memitem:gac90c6bea00e1c6fdf9e39b360ccfa81c"><td class="memTemplItemLeft" align="right" valign="top">Slot1&lt; R, P1 &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00159.html#gac90c6bea00e1c6fdf9e39b360ccfa81c">scim::slot</a> (T1 *&amp;object, R(T2::*function)(P1))</td></tr>
<tr class="separator:gac90c6bea00e1c6fdf9e39b360ccfa81c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d90904a4786401f9afd6463bf1e86bb"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename R , typename P1 &gt; </td></tr>
<tr class="memitem:ga3d90904a4786401f9afd6463bf1e86bb"><td class="memTemplItemLeft" align="right" valign="top">Slot1&lt; R, P1 &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00159.html#ga3d90904a4786401f9afd6463bf1e86bb">scim::slot</a> (T1 *const &amp;object, R(T2::*function)(P1))</td></tr>
<tr class="separator:ga3d90904a4786401f9afd6463bf1e86bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0f5672b9bdacf513f09da400420a359"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename R , typename P1 &gt; </td></tr>
<tr class="memitem:gaa0f5672b9bdacf513f09da400420a359"><td class="memTemplItemLeft" align="right" valign="top">Slot1&lt; R, P1 &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00159.html#gaa0f5672b9bdacf513f09da400420a359">scim::slot</a> (T1 &amp;object, R(T2::*function)(P1))</td></tr>
<tr class="separator:gaa0f5672b9bdacf513f09da400420a359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2de2fc048e32e48576eca17d5ec35753"><td class="memTemplParams" colspan="2">template&lt;typename R , typename P1 , typename P2 &gt; </td></tr>
<tr class="memitem:ga2de2fc048e32e48576eca17d5ec35753"><td class="memTemplItemLeft" align="right" valign="top">Slot2&lt; R, P1, P2 &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00159.html#ga2de2fc048e32e48576eca17d5ec35753">scim::slot</a> (R(*function)(P1, P2))</td></tr>
<tr class="separator:ga2de2fc048e32e48576eca17d5ec35753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83dfb61d3f2f95a9f4027439edb74b40"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename R , typename P1 , typename P2 &gt; </td></tr>
<tr class="memitem:ga83dfb61d3f2f95a9f4027439edb74b40"><td class="memTemplItemLeft" align="right" valign="top">Slot2&lt; R, P1, P2 &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00159.html#ga83dfb61d3f2f95a9f4027439edb74b40">scim::slot</a> (T1 *&amp;object, R(T2::*function)(P1, P2))</td></tr>
<tr class="separator:ga83dfb61d3f2f95a9f4027439edb74b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga351b1750ed34358cfb104a300e0bbcb6"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename R , typename P1 , typename P2 &gt; </td></tr>
<tr class="memitem:ga351b1750ed34358cfb104a300e0bbcb6"><td class="memTemplItemLeft" align="right" valign="top">Slot2&lt; R, P1, P2 &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00159.html#ga351b1750ed34358cfb104a300e0bbcb6">scim::slot</a> (T1 *const &amp;object, R(T2::*function)(P1, P2))</td></tr>
<tr class="separator:ga351b1750ed34358cfb104a300e0bbcb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b45230e568bc2e061932f38ee699b54"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename R , typename P1 , typename P2 &gt; </td></tr>
<tr class="memitem:ga9b45230e568bc2e061932f38ee699b54"><td class="memTemplItemLeft" align="right" valign="top">Slot2&lt; R, P1, P2 &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00159.html#ga9b45230e568bc2e061932f38ee699b54">scim::slot</a> (T1 &amp;object, R(T2::*function)(P1, P2))</td></tr>
<tr class="separator:ga9b45230e568bc2e061932f38ee699b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26ad5bef38560ec5bcce773384b8919f"><td class="memTemplParams" colspan="2">template&lt;typename R , typename P1 , typename P2 , typename P3 &gt; </td></tr>
<tr class="memitem:ga26ad5bef38560ec5bcce773384b8919f"><td class="memTemplItemLeft" align="right" valign="top">Slot3&lt; R, P1, P2, P3 &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00159.html#ga26ad5bef38560ec5bcce773384b8919f">scim::slot</a> (R(*function)(P1, P2, P3))</td></tr>
<tr class="separator:ga26ad5bef38560ec5bcce773384b8919f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57c2b63bbdf5afddb7f590cc2bebbb59"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename R , typename P1 , typename P2 , typename P3 &gt; </td></tr>
<tr class="memitem:ga57c2b63bbdf5afddb7f590cc2bebbb59"><td class="memTemplItemLeft" align="right" valign="top">Slot3&lt; R, P1, P2, P3 &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00159.html#ga57c2b63bbdf5afddb7f590cc2bebbb59">scim::slot</a> (T1 *&amp;object, R(T2::*function)(P1, P2, P3))</td></tr>
<tr class="separator:ga57c2b63bbdf5afddb7f590cc2bebbb59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37e74d3295abbaab5b86878bdca87938"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename R , typename P1 , typename P2 , typename P3 &gt; </td></tr>
<tr class="memitem:ga37e74d3295abbaab5b86878bdca87938"><td class="memTemplItemLeft" align="right" valign="top">Slot3&lt; R, P1, P2, P3 &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00159.html#ga37e74d3295abbaab5b86878bdca87938">scim::slot</a> (T1 *const &amp;object, R(T2::*function)(P1, P2, P3))</td></tr>
<tr class="separator:ga37e74d3295abbaab5b86878bdca87938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab13230e88dc363621413b9b95c141ef0"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename R , typename P1 , typename P2 , typename P3 &gt; </td></tr>
<tr class="memitem:gab13230e88dc363621413b9b95c141ef0"><td class="memTemplItemLeft" align="right" valign="top">Slot3&lt; R, P1, P2, P3 &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00159.html#gab13230e88dc363621413b9b95c141ef0">scim::slot</a> (T1 &amp;object, R(T2::*function)(P1, P2, P3))</td></tr>
<tr class="separator:gab13230e88dc363621413b9b95c141ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad52d53f728cc4db5a75371444f5494db"><td class="memTemplParams" colspan="2">template&lt;typename R , typename P1 , typename P2 , typename P3 , typename P4 &gt; </td></tr>
<tr class="memitem:gad52d53f728cc4db5a75371444f5494db"><td class="memTemplItemLeft" align="right" valign="top">Slot4&lt; R, P1, P2, P3, P4 &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00159.html#gad52d53f728cc4db5a75371444f5494db">scim::slot</a> (R(*function)(P1, P2, P3, P4))</td></tr>
<tr class="separator:gad52d53f728cc4db5a75371444f5494db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8590856f29dacf013e0c9fac71c6486a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename R , typename P1 , typename P2 , typename P3 , typename P4 &gt; </td></tr>
<tr class="memitem:ga8590856f29dacf013e0c9fac71c6486a"><td class="memTemplItemLeft" align="right" valign="top">Slot4&lt; R, P1, P2, P3, P4 &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00159.html#ga8590856f29dacf013e0c9fac71c6486a">scim::slot</a> (T1 *&amp;object, R(T2::*function)(P1, P2, P3, P4))</td></tr>
<tr class="separator:ga8590856f29dacf013e0c9fac71c6486a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f553304cd72ecdfdcd36e8b0805df7f"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename R , typename P1 , typename P2 , typename P3 , typename P4 &gt; </td></tr>
<tr class="memitem:ga0f553304cd72ecdfdcd36e8b0805df7f"><td class="memTemplItemLeft" align="right" valign="top">Slot4&lt; R, P1, P2, P3, P4 &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00159.html#ga0f553304cd72ecdfdcd36e8b0805df7f">scim::slot</a> (T1 *const &amp;object, R(T2::*function)(P1, P2, P3, P4))</td></tr>
<tr class="separator:ga0f553304cd72ecdfdcd36e8b0805df7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca5cec890763b681def0ddf676664f42"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename R , typename P1 , typename P2 , typename P3 , typename P4 &gt; </td></tr>
<tr class="memitem:gaca5cec890763b681def0ddf676664f42"><td class="memTemplItemLeft" align="right" valign="top">Slot4&lt; R, P1, P2, P3, P4 &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00159.html#gaca5cec890763b681def0ddf676664f42">scim::slot</a> (T1 &amp;object, R(T2::*function)(P1, P2, P3, P4))</td></tr>
<tr class="separator:gaca5cec890763b681def0ddf676664f42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbd10e973afb6a5e5fe844106ff40fdf"><td class="memTemplParams" colspan="2">template&lt;typename R , typename P1 , typename P2 , typename P3 , typename P4 , typename P5 &gt; </td></tr>
<tr class="memitem:gabbd10e973afb6a5e5fe844106ff40fdf"><td class="memTemplItemLeft" align="right" valign="top">Slot5&lt; R, P1, P2, P3, P4, P5 &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00159.html#gabbd10e973afb6a5e5fe844106ff40fdf">scim::slot</a> (R(*function)(P1, P2, P3, P4, P5))</td></tr>
<tr class="separator:gabbd10e973afb6a5e5fe844106ff40fdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84383a3ff46ff75bc9f845831940a50e"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename R , typename P1 , typename P2 , typename P3 , typename P4 , typename P5 &gt; </td></tr>
<tr class="memitem:ga84383a3ff46ff75bc9f845831940a50e"><td class="memTemplItemLeft" align="right" valign="top">Slot5&lt; R, P1, P2, P3, P4, P5 &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00159.html#ga84383a3ff46ff75bc9f845831940a50e">scim::slot</a> (T1 *&amp;object, R(T2::*function)(P1, P2, P3, P4, P5))</td></tr>
<tr class="separator:ga84383a3ff46ff75bc9f845831940a50e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1649ce280465410193eb9c7c567b36b3"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename R , typename P1 , typename P2 , typename P3 , typename P4 , typename P5 &gt; </td></tr>
<tr class="memitem:ga1649ce280465410193eb9c7c567b36b3"><td class="memTemplItemLeft" align="right" valign="top">Slot5&lt; R, P1, P2, P3, P4, P5 &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00159.html#ga1649ce280465410193eb9c7c567b36b3">scim::slot</a> (T1 *const &amp;object, R(T2::*function)(P1, P2, P3, P4, P5))</td></tr>
<tr class="separator:ga1649ce280465410193eb9c7c567b36b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1ef92be5a482a38f1dc5026a1ba3e71"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename R , typename P1 , typename P2 , typename P3 , typename P4 , typename P5 &gt; </td></tr>
<tr class="memitem:gab1ef92be5a482a38f1dc5026a1ba3e71"><td class="memTemplItemLeft" align="right" valign="top">Slot5&lt; R, P1, P2, P3, P4, P5 &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00159.html#gab1ef92be5a482a38f1dc5026a1ba3e71">scim::slot</a> (T1 &amp;object, R(T2::*function)(P1, P2, P3, P4, P5))</td></tr>
<tr class="separator:gab1ef92be5a482a38f1dc5026a1ba3e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b2da7eec3c3878ba3ff991e0951214e"><td class="memTemplParams" colspan="2">template&lt;typename R , typename P1 , typename P2 , typename P3 , typename P4 , typename P5 , typename P6 &gt; </td></tr>
<tr class="memitem:ga8b2da7eec3c3878ba3ff991e0951214e"><td class="memTemplItemLeft" align="right" valign="top">Slot6&lt; R, P1, P2, P3, P4, P5, <br class="typebreak" />
P6 &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00159.html#ga8b2da7eec3c3878ba3ff991e0951214e">scim::slot</a> (R(*function)(P1, P2, P3, P4, P5, P6))</td></tr>
<tr class="separator:ga8b2da7eec3c3878ba3ff991e0951214e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bbb16f86a6e394bf609fe7ef40ca14e"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename R , typename P1 , typename P2 , typename P3 , typename P4 , typename P5 , typename P6 &gt; </td></tr>
<tr class="memitem:ga7bbb16f86a6e394bf609fe7ef40ca14e"><td class="memTemplItemLeft" align="right" valign="top">Slot6&lt; R, P1, P2, P3, P4, P5, <br class="typebreak" />
P6 &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00159.html#ga7bbb16f86a6e394bf609fe7ef40ca14e">scim::slot</a> (T1 *&amp;object, R(T2::*function)(P1, P2, P3, P4, P5, P6))</td></tr>
<tr class="separator:ga7bbb16f86a6e394bf609fe7ef40ca14e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae529c1f1a1602338f5d88c6f0fc964c4"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename R , typename P1 , typename P2 , typename P3 , typename P4 , typename P5 , typename P6 &gt; </td></tr>
<tr class="memitem:gae529c1f1a1602338f5d88c6f0fc964c4"><td class="memTemplItemLeft" align="right" valign="top">Slot6&lt; R, P1, P2, P3, P4, P5, <br class="typebreak" />
P6 &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00159.html#gae529c1f1a1602338f5d88c6f0fc964c4">scim::slot</a> (T1 *const &amp;object, R(T2::*function)(P1, P2, P3, P4, P5, P6))</td></tr>
<tr class="separator:gae529c1f1a1602338f5d88c6f0fc964c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab749aaacb506c445b4d62b5f1f484658"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename R , typename P1 , typename P2 , typename P3 , typename P4 , typename P5 , typename P6 &gt; </td></tr>
<tr class="memitem:gab749aaacb506c445b4d62b5f1f484658"><td class="memTemplItemLeft" align="right" valign="top">Slot6&lt; R, P1, P2, P3, P4, P5, <br class="typebreak" />
P6 &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00159.html#gab749aaacb506c445b4d62b5f1f484658">scim::slot</a> (T1 &amp;object, R(T2::*function)(P1, P2, P3, P4, P5, P6))</td></tr>
<tr class="separator:gab749aaacb506c445b4d62b5f1f484658"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The classes for signal/slot mechanism. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gab6dcccafea2fb2ef5c514269f0100482"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename P1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Slot0&lt;R&gt;* scim::bind </td>
          <td>(</td>
          <td class="paramtype">Slot1&lt; R, P1 &gt; *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P1&#160;</td>
          <td class="paramname"><em>p1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloaded <a class="el" href="a00159.html#gab6dcccafea2fb2ef5c514269f0100482">bind()</a> factory function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>- a slot of type Slot1&lt;R, P1&gt;. </td></tr>
    <tr><td class="paramname">p1</td><td>- a value of type P1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new slot that stores the value p1.</dd></dl>
<p><br />
When then returned slot is called it calls the original slot <em>s</em>, passing it the arguments passed to it and the value <em>p1</em>, as the last parameter. If the returned slot is connected to a signal it doesn't have to be unreferenced. The signal it's connected to will unreference the slot when it is destroyed. Otherwise the slot must be unreferenced by calling unref(). </p>

</div>
</div>
<a class="anchor" id="ga81772fbc92c59e8e2569bc646a4024a0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename P1 , typename P2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Slot1&lt;R, P1&gt;* scim::bind </td>
          <td>(</td>
          <td class="paramtype">Slot2&lt; R, P1, P2 &gt; *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P2&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloaded <a class="el" href="a00159.html#gab6dcccafea2fb2ef5c514269f0100482">bind()</a> factory function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>- a slot of type Slot1&lt;R, P1, P2&gt;. </td></tr>
    <tr><td class="paramname">p2</td><td>- a value of type P2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new slot that stores the value p2.</dd></dl>
<p><br />
When then returned slot is called it calls the original slot <em>s</em>, passing it the arguments passed to it and the value <em>p2</em>, as the last parameter. If the returned slot is connected to a signal it doesn't have to be unreferenced. The signal it's connected to will unreference the slot when it is destroyed. Otherwise the slot must be unreferenced by calling unref(). </p>

</div>
</div>
<a class="anchor" id="gac2380df642d6efaa8aa728c1930d64a3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename P1 , typename P2 , typename P3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Slot2&lt;R, P1, P2&gt;* scim::bind </td>
          <td>(</td>
          <td class="paramtype">Slot3&lt; R, P1, P2, P3 &gt; *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P3&#160;</td>
          <td class="paramname"><em>p3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloaded <a class="el" href="a00159.html#gab6dcccafea2fb2ef5c514269f0100482">bind()</a> factory function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>- a slot of type Slot1&lt;R, P1, P2, P3&gt;. </td></tr>
    <tr><td class="paramname">p3</td><td>- a value of type P3. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new slot that stores the value p3.</dd></dl>
<p><br />
When then returned slot is called it calls the original slot <em>s</em>, passing it the arguments passed to it and the value <em>p3</em>, as the last parameter. If the returned slot is connected to a signal it doesn't have to be unreferenced. The signal it's connected to will unreference the slot when it is destroyed. Otherwise the slot must be unreferenced by calling unref(). </p>

</div>
</div>
<a class="anchor" id="gab28fb1b03488cdaf7917019284bf571e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename P1 , typename P2 , typename P3 , typename P4 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Slot3&lt;R, P1, P2, P3&gt;* scim::bind </td>
          <td>(</td>
          <td class="paramtype">Slot4&lt; R, P1, P2, P3, P4 &gt; *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P4&#160;</td>
          <td class="paramname"><em>p4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloaded <a class="el" href="a00159.html#gab6dcccafea2fb2ef5c514269f0100482">bind()</a> factory function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>- a slot of type Slot1&lt;R, P1, P2, P3, P4&gt;. </td></tr>
    <tr><td class="paramname">p4</td><td>- a value of type P4. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new slot that stores the value p4.</dd></dl>
<p><br />
When then returned slot is called it calls the original slot <em>s</em>, passing it the arguments passed to it and the value <em>p4</em>, as the last parameter. If the returned slot is connected to a signal it doesn't have to be unreferenced. The signal it's connected to will unreference the slot when it is destroyed. Otherwise the slot must be unreferenced by calling unref(). </p>

</div>
</div>
<a class="anchor" id="gab739be9d680167831b4ae12c32ac2b73"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename P1 , typename P2 , typename P3 , typename P4 , typename P5 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Slot4&lt;R, P1, P2, P3, P4&gt;* scim::bind </td>
          <td>(</td>
          <td class="paramtype">Slot5&lt; R, P1, P2, P3, P4, P5 &gt; *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P5&#160;</td>
          <td class="paramname"><em>p5</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloaded <a class="el" href="a00159.html#gab6dcccafea2fb2ef5c514269f0100482">bind()</a> factory function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>- a slot of type Slot1&lt;R, P1, P2, P3, P4, P5&gt;. </td></tr>
    <tr><td class="paramname">p5</td><td>- a value of type P5. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new slot that stores the value p5.</dd></dl>
<p><br />
When then returned slot is called it calls the original slot <em>s</em>, passing it the arguments passed to it and the value <em>p5</em>, as the last parameter. If the returned slot is connected to a signal it doesn't have to be unreferenced. The signal it's connected to will unreference the slot when it is destroyed. Otherwise the slot must be unreferenced by calling unref(). </p>

</div>
</div>
<a class="anchor" id="gaa885cc0b753b1b2425a9fdf657489a80"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename P1 , typename P2 , typename P3 , typename P4 , typename P5 , typename P6 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Slot5&lt;R, P1, P2, P3, P4, P5&gt;* scim::bind </td>
          <td>(</td>
          <td class="paramtype">Slot6&lt; R, P1, P2, P3, P4, P5, P6 &gt; *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P6&#160;</td>
          <td class="paramname"><em>p6</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloaded <a class="el" href="a00159.html#gab6dcccafea2fb2ef5c514269f0100482">bind()</a> factory function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>- a slot of type Slot1&lt;R, P1, P2, P3, P4, P5, P6&gt;. </td></tr>
    <tr><td class="paramname">p6</td><td>- a value of type P6. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new slot that stores the value p6.</dd></dl>
<p><br />
When then returned slot is called it calls the original slot <em>s</em>, passing it the arguments passed to it and the value <em>p6</em>, as the last parameter. If the returned slot is connected to a signal it doesn't have to be unreferenced. The signal it's connected to will unreference the slot when it is destroyed. Otherwise the slot must be unreferenced by calling unref(). </p>

</div>
</div>
<a class="anchor" id="ga427440baa70c0064d62297ab75e288c0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Slot0&lt;R&gt;* scim::slot </td>
          <td>(</td>
          <td class="paramtype">R(*)()&#160;</td>
          <td class="paramname"><em>function</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloaded slot factory function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>- a static function with the signature R (*function)(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new slot passing no arguments and returning a value of type R.</dd></dl>
<p><br />
If the returned slot is connected to a signal it doesn't have to be unreferenced. The signal it's connected to will unreference the slot when it is destroyed. Otherwise the slot must be unreferenced by calling unref(). </p>

</div>
</div>
<a class="anchor" id="gab542dd0c8878b9c550ef8a1dd59fda2e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Slot0&lt;R&gt;* scim::slot </td>
          <td>(</td>
          <td class="paramtype">T1 *&amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T2::*)()&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloaded slot factory function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>- a reference to a pointer to an object of type T1. </td></tr>
    <tr><td class="paramname">function</td><td>- a class method with the signature R (T2::*function)(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new slot passing no arguments and returning a value of type R.</dd></dl>
<p><br />
T1 can be the same object type as T2. If the returned slot is connected to a signal it doesn't have to be unreferenced. The signal it's connected to will unreference the slot when it is destroyed. Otherwise the slot must be unreferenced by calling unref(). </p>

</div>
</div>
<a class="anchor" id="ga8c11533f9ddcce825b5abcd1c4e959c2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Slot0&lt;R&gt;* scim::slot </td>
          <td>(</td>
          <td class="paramtype">T1 *const &amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T2::*)()&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloaded slot factory function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>- a reference to a const pointer to an object of type T1 (e.g. this). </td></tr>
    <tr><td class="paramname">function</td><td>- a class method with the signature R (T2::*function)(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new slot passing no arguments and returning a value of type R.</dd></dl>
<p><br />
T1 can be the same object type as T2. If the returned slot is connected to a signal it doesn't have to be unreferenced. The signal it's connected to will unreference the slot when it is destroyed. Otherwise the slot must be unreferenced by calling unref(). </p>

</div>
</div>
<a class="anchor" id="gaef2807b9ee3148787275b46a85648b9e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Slot0&lt;R&gt;* scim::slot </td>
          <td>(</td>
          <td class="paramtype">T1 &amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T2::*)()&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloaded slot factory function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>- a reference to an object of type T1. </td></tr>
    <tr><td class="paramname">function</td><td>- a class method with the signature R (T2::*function)(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new slot passing no arguments and returning a value of type R.</dd></dl>
<p><br />
T1 can be the same object type as T2. If the returned slot is connected to a signal it doesn't have to be unreferenced. The signal it's connected to will unreference the slot when it is destroyed. Otherwise the slot must be unreferenced by calling unref(). </p>

</div>
</div>
<a class="anchor" id="gafa26187744e103060a603f03da82b3a3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename P1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Slot1&lt;R, P1&gt;* scim::slot </td>
          <td>(</td>
          <td class="paramtype">R(*)(P1)&#160;</td>
          <td class="paramname"><em>function</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloaded slot factory function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>- a static function with the signature R (*function)(P1). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new slot passing one argument of type P1 and returning a value of type R.</dd></dl>
<p><br />
If the returned slot is connected to a signal it doesn't have to be unreferenced. The signal it's connected to will unreference the slot when it is destroyed. Otherwise the slot must be unreferenced by calling unref(). </p>

</div>
</div>
<a class="anchor" id="gac90c6bea00e1c6fdf9e39b360ccfa81c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename R , typename P1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Slot1&lt;R, P1&gt;* scim::slot </td>
          <td>(</td>
          <td class="paramtype">T1 *&amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T2::*)(P1)&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloaded slot factory function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>- a reference to a pointer to an object of type T1. </td></tr>
    <tr><td class="paramname">function</td><td>- a class method with the signature R (T2::*function)(P1). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new slot passing one argument of type P1 and returning a value of type R.</dd></dl>
<p><br />
T1 can be the same object type as T2. If the returned slot is connected to a signal it doesn't have to be unreferenced. The signal it's connected to will unreference the slot when it is destroyed. Otherwise the slot must be unreferenced by calling unref(). </p>

</div>
</div>
<a class="anchor" id="ga3d90904a4786401f9afd6463bf1e86bb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename R , typename P1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Slot1&lt;R, P1&gt;* scim::slot </td>
          <td>(</td>
          <td class="paramtype">T1 *const &amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T2::*)(P1)&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloaded slot factory function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>- a reference to a const pointer to an object of type T1 (e.g. this). </td></tr>
    <tr><td class="paramname">function</td><td>- a class method with the signature R (T2::*function)(P1). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new slot passing one argument of type P1 and returning a value of type R.</dd></dl>
<p><br />
T1 can be the same object type as T2. If the returned slot is connected to a signal it doesn't have to be unreferenced. The signal it's connected to will unreference the slot when it is destroyed. Otherwise the slot must be unreferenced by calling unref(). </p>

</div>
</div>
<a class="anchor" id="gaa0f5672b9bdacf513f09da400420a359"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename R , typename P1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Slot1&lt;R, P1&gt;* scim::slot </td>
          <td>(</td>
          <td class="paramtype">T1 &amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T2::*)(P1)&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloaded slot factory function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>- a reference to an object of type T1. </td></tr>
    <tr><td class="paramname">function</td><td>- a class method with the signature R (T2::*function)(P1). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new slot passing one argument of type P1 and returning a value of type R.</dd></dl>
<p><br />
T1 can be the same object type as T2. If the returned slot is connected to a signal it doesn't have to be unreferenced. The signal it's connected to will unreference the slot when it is destroyed. Otherwise the slot must be unreferenced by calling unref(). </p>

</div>
</div>
<a class="anchor" id="ga2de2fc048e32e48576eca17d5ec35753"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename P1 , typename P2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Slot2&lt;R, P1, P2&gt;* scim::slot </td>
          <td>(</td>
          <td class="paramtype">R(*)(P1, P2)&#160;</td>
          <td class="paramname"><em>function</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloaded slot factory function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>- a static function with the signature R (*function)(P1, P2). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new slot passing two arguments of type P1 and P2, and returning a value of type R.</dd></dl>
<p><br />
If the returned slot is connected to a signal it doesn't have to be unreferenced. The signal it's connected to will unreference the slot when it is destroyed. Otherwise the slot must be unreferenced by calling unref(). </p>

</div>
</div>
<a class="anchor" id="ga83dfb61d3f2f95a9f4027439edb74b40"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename R , typename P1 , typename P2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Slot2&lt;R, P1, P2&gt;* scim::slot </td>
          <td>(</td>
          <td class="paramtype">T1 *&amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T2::*)(P1, P2)&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloaded slot factory function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>- a reference to a pointer to an object of type T1. </td></tr>
    <tr><td class="paramname">function</td><td>- a class method with the signature R (T2::*function)(P1, P2). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new slot passing two arguments of type P1 and P2, and returning a value of type R.</dd></dl>
<p><br />
T1 can be the same object type as T2. If the returned slot is connected to a signal it doesn't have to be unreferenced. The signal it's connected to will unreference the slot when it is destroyed. Otherwise the slot must be unreferenced by calling unref(). </p>

</div>
</div>
<a class="anchor" id="ga351b1750ed34358cfb104a300e0bbcb6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename R , typename P1 , typename P2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Slot2&lt;R, P1, P2&gt;* scim::slot </td>
          <td>(</td>
          <td class="paramtype">T1 *const &amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T2::*)(P1, P2)&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloaded slot factory function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>- a reference to a const pointer to an object of type T1 (e.g. this). </td></tr>
    <tr><td class="paramname">function</td><td>- a class method with the signature R (T2::*function)(P1, P2). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new slot passing two arguments of type P1 and P2, and returning a value of type R.</dd></dl>
<p><br />
T1 can be the same object type as T2. If the returned slot is connected to a signal it doesn't have to be unreferenced. The signal it's connected to will unreference the slot when it is destroyed. Otherwise the slot must be unreferenced by calling unref(). </p>

</div>
</div>
<a class="anchor" id="ga9b45230e568bc2e061932f38ee699b54"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename R , typename P1 , typename P2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Slot2&lt;R, P1, P2&gt;* scim::slot </td>
          <td>(</td>
          <td class="paramtype">T1 &amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T2::*)(P1, P2)&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloaded slot factory function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>- a reference to an object of type T1. </td></tr>
    <tr><td class="paramname">function</td><td>- a class method with the signature R (T2::*function)(P1, P2). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new slot passing two arguments of type P1 and P2, and returning a value of type R.</dd></dl>
<p><br />
T1 can be the same object type as T2. If the returned slot is connected to a signal it doesn't have to be unreferenced. The signal it's connected to will unreference the slot when it is destroyed. Otherwise the slot must be unreferenced by calling unref(). </p>

</div>
</div>
<a class="anchor" id="ga26ad5bef38560ec5bcce773384b8919f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename P1 , typename P2 , typename P3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Slot3&lt;R, P1, P2, P3&gt;* scim::slot </td>
          <td>(</td>
          <td class="paramtype">R(*)(P1, P2, P3)&#160;</td>
          <td class="paramname"><em>function</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloaded slot factory function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>- a static function with the signature R (*function)(P1, P2, P3). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new slot passing three arguments of type P1, P2 and P3, and returning a value of type R.</dd></dl>
<p><br />
If the returned slot is connected to a signal it doesn't have to be unreferenced. The signal it's connected to will unreference the slot when it is destroyed. Otherwise the slot must be unreferenced by calling unref(). </p>

</div>
</div>
<a class="anchor" id="ga57c2b63bbdf5afddb7f590cc2bebbb59"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename R , typename P1 , typename P2 , typename P3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Slot3&lt;R, P1, P2, P3&gt;* scim::slot </td>
          <td>(</td>
          <td class="paramtype">T1 *&amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T2::*)(P1, P2, P3)&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloaded slot factory function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>- a reference to a pointer to an object of type T1. </td></tr>
    <tr><td class="paramname">function</td><td>- a class method with the signature R (T2::*function)(P1, P2, P3). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new slot passing three arguments of type P1, P2 and P3, and returning a value of type R.</dd></dl>
<p><br />
T1 can be the same object type as T2. If the returned slot is connected to a signal it doesn't have to be unreferenced. The signal it's connected to will unreference the slot when it is destroyed. Otherwise the slot must be unreferenced by calling unref(). </p>

</div>
</div>
<a class="anchor" id="ga37e74d3295abbaab5b86878bdca87938"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename R , typename P1 , typename P2 , typename P3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Slot3&lt;R, P1, P2, P3&gt;* scim::slot </td>
          <td>(</td>
          <td class="paramtype">T1 *const &amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T2::*)(P1, P2, P3)&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloaded slot factory function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>- a reference to a const pointer to an object of type T1 (e.g. this). </td></tr>
    <tr><td class="paramname">function</td><td>- a class method with the signature R (T2::*function)(P1, P2, P3). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new slot passing three arguments of type P1, P2 and P3, and returning a value of type R.</dd></dl>
<p><br />
T1 can be the same object type as T2. If the returned slot is connected to a signal it doesn't have to be unreferenced. The signal it's connected to will unreference the slot when it is destroyed. Otherwise the slot must be unreferenced by calling unref(). </p>

</div>
</div>
<a class="anchor" id="gab13230e88dc363621413b9b95c141ef0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename R , typename P1 , typename P2 , typename P3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Slot3&lt;R, P1, P2, P3&gt;* scim::slot </td>
          <td>(</td>
          <td class="paramtype">T1 &amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T2::*)(P1, P2, P3)&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloaded slot factory function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>- a reference to an object of type T1. </td></tr>
    <tr><td class="paramname">function</td><td>- a class method with the signature R (T2::*function)(P1, P2, P3). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new slot passing three arguments of type P1, P2 and P3, and returning a value of type R.</dd></dl>
<p><br />
T1 can be the same object type as T2. If the returned slot is connected to a signal it doesn't have to be unreferenced. The signal it's connected to will unreference the slot when it is destroyed. Otherwise the slot must be unreferenced by calling unref(). </p>

</div>
</div>
<a class="anchor" id="gad52d53f728cc4db5a75371444f5494db"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename P1 , typename P2 , typename P3 , typename P4 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Slot4&lt;R, P1, P2, P3, P4&gt;* scim::slot </td>
          <td>(</td>
          <td class="paramtype">R(*)(P1, P2, P3, P4)&#160;</td>
          <td class="paramname"><em>function</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloaded slot factory function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>- a static function with the signature R (*function)(P1, P2, P3, P4). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new slot passing four arguments of type P1, P2, P3 and P4, and returning a value of type R.</dd></dl>
<p><br />
If the returned slot is connected to a signal it doesn't have to be unreferenced. The signal it's connected to will unreference the slot when it is destroyed. Otherwise the slot must be unreferenced by calling unref(). </p>

</div>
</div>
<a class="anchor" id="ga8590856f29dacf013e0c9fac71c6486a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename R , typename P1 , typename P2 , typename P3 , typename P4 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Slot4&lt;R, P1, P2, P3, P4&gt;* scim::slot </td>
          <td>(</td>
          <td class="paramtype">T1 *&amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T2::*)(P1, P2, P3, P4)&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloaded slot factory function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>- a reference to a pointer to an object of type T1. </td></tr>
    <tr><td class="paramname">function</td><td>- a class method with the signature R (T2::*function)(P1, P2, P3, P4). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new slot passing four arguments of type P1, P2, P3 and P4, and returning a value of type R.</dd></dl>
<p><br />
T1 can be the same object type as T2. If the returned slot is connected to a signal it doesn't have to be unreferenced. The signal it's connected to will unreference the slot when it is destroyed. Otherwise the slot must be unreferenced by calling unref(). </p>

</div>
</div>
<a class="anchor" id="ga0f553304cd72ecdfdcd36e8b0805df7f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename R , typename P1 , typename P2 , typename P3 , typename P4 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Slot4&lt;R, P1, P2, P3, P4&gt;* scim::slot </td>
          <td>(</td>
          <td class="paramtype">T1 *const &amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T2::*)(P1, P2, P3, P4)&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloaded slot factory function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>- a reference to a const pointer to an object of type T1 (e.g. this). </td></tr>
    <tr><td class="paramname">function</td><td>- a class method with the signature R (T2::*function)(P1, P2, P3, P4). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new slot passing four arguments of type P1, P2, P3 and P4, and returning a value of type R.</dd></dl>
<p><br />
T1 can be the same object type as T2. If the returned slot is connected to a signal it doesn't have to be unreferenced. The signal it's connected to will unreference the slot when it is destroyed. Otherwise the slot must be unreferenced by calling unref(). </p>

</div>
</div>
<a class="anchor" id="gaca5cec890763b681def0ddf676664f42"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename R , typename P1 , typename P2 , typename P3 , typename P4 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Slot4&lt;R, P1, P2, P3, P4&gt;* scim::slot </td>
          <td>(</td>
          <td class="paramtype">T1 &amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T2::*)(P1, P2, P3, P4)&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloaded slot factory function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>- a reference to an object of type T1. </td></tr>
    <tr><td class="paramname">function</td><td>- a class method with the signature R (T2::*function)(P1, P2, P3, P4). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new slot passing four arguments of type P1, P2, P3 and P4, and returning a value of type R.</dd></dl>
<p><br />
T1 can be the same object type as T2. If the returned slot is connected to a signal it doesn't have to be unreferenced. The signal it's connected to will unreference the slot when it is destroyed. Otherwise the slot must be unreferenced by calling unref(). </p>

</div>
</div>
<a class="anchor" id="gabbd10e973afb6a5e5fe844106ff40fdf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename P1 , typename P2 , typename P3 , typename P4 , typename P5 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Slot5&lt;R, P1, P2, P3, P4, P5&gt;* scim::slot </td>
          <td>(</td>
          <td class="paramtype">R(*)(P1, P2, P3, P4, P5)&#160;</td>
          <td class="paramname"><em>function</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloaded slot factory function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>- a static function with the signature R (*function)(P1, P2, P3, P4, P5). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new slot passing five arguments of type P1, P2, P3, P4 and P5, and returning a value of type R.</dd></dl>
<p><br />
If the returned slot is connected to a signal it doesn't have to be unreferenced. The signal it's connected to will unreference the slot when it is destroyed. Otherwise the slot must be unreferenced by calling unref(). </p>

</div>
</div>
<a class="anchor" id="ga84383a3ff46ff75bc9f845831940a50e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename R , typename P1 , typename P2 , typename P3 , typename P4 , typename P5 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Slot5&lt;R, P1, P2, P3, P4, P5&gt;* scim::slot </td>
          <td>(</td>
          <td class="paramtype">T1 *&amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T2::*)(P1, P2, P3, P4, P5)&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloaded slot factory function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>- a reference to a pointer to an object of type T1. </td></tr>
    <tr><td class="paramname">function</td><td>- a class method with the signature R (T2::*function)(P1, P2, P3, P4, P5). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new slot passing five arguments of type P1, P2, P3, P4 and P5, and returning a value of type R.</dd></dl>
<p><br />
T1 can be the same object type as T2. If the returned slot is connected to a signal it doesn't have to be unreferenced. The signal it's connected to will unreference the slot when it is destroyed. Otherwise the slot must be unreferenced by calling unref(). </p>

</div>
</div>
<a class="anchor" id="ga1649ce280465410193eb9c7c567b36b3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename R , typename P1 , typename P2 , typename P3 , typename P4 , typename P5 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Slot5&lt;R, P1, P2, P3, P4, P5&gt;* scim::slot </td>
          <td>(</td>
          <td class="paramtype">T1 *const &amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T2::*)(P1, P2, P3, P4, P5)&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloaded slot factory function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>- a reference to a const pointer to an object of type T1 (e.g. this). </td></tr>
    <tr><td class="paramname">function</td><td>- a class method with the signature R (T2::*function)(P1, P2, P3, P4, P5). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new slot passing five arguments of type P1, P2, P3, P4 and P5, and returning a value of type R.</dd></dl>
<p><br />
T1 can be the same object type as T2. If the returned slot is connected to a signal it doesn't have to be unreferenced. The signal it's connected to will unreference the slot when it is destroyed. Otherwise the slot must be unreferenced by calling unref(). </p>

</div>
</div>
<a class="anchor" id="gab1ef92be5a482a38f1dc5026a1ba3e71"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename R , typename P1 , typename P2 , typename P3 , typename P4 , typename P5 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Slot5&lt;R, P1, P2, P3, P4, P5&gt;* scim::slot </td>
          <td>(</td>
          <td class="paramtype">T1 &amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T2::*)(P1, P2, P3, P4, P5)&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloaded slot factory function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>- a reference to an object of type T1. </td></tr>
    <tr><td class="paramname">function</td><td>- a class method with the signature R (T2::*function)(P1, P2, P3, P4, P5). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new slot passing five arguments of type P1, P2, P3, P4 and P5, and returning a value of type R.</dd></dl>
<p><br />
T1 can be the same object type as T2. If the returned slot is connected to a signal it doesn't have to be unreferenced. The signal it's connected to will unreference the slot when it is destroyed. Otherwise the slot must be unreferenced by calling unref(). </p>

</div>
</div>
<a class="anchor" id="ga8b2da7eec3c3878ba3ff991e0951214e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename P1 , typename P2 , typename P3 , typename P4 , typename P5 , typename P6 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Slot6&lt;R, P1, P2, P3, P4, P5, P6&gt;* scim::slot </td>
          <td>(</td>
          <td class="paramtype">R(*)(P1, P2, P3, P4, P5, P6)&#160;</td>
          <td class="paramname"><em>function</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloaded slot factory function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>- a static function with the signature R (*function)(P1, P2, P3, P4, P5, P6). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new slot passing six arguments of type P1, P2, P3, P4, P5 and P6, and returning a value of type R.</dd></dl>
<p><br />
If the returned slot is connected to a signal it doesn't have to be unreferenced. The signal it's connected to will unreference the slot when it is destroyed. Otherwise the slot must be unreferenced by calling unref(). </p>

</div>
</div>
<a class="anchor" id="ga7bbb16f86a6e394bf609fe7ef40ca14e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename R , typename P1 , typename P2 , typename P3 , typename P4 , typename P5 , typename P6 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Slot6&lt;R, P1, P2, P3, P4, P5, P6&gt;* scim::slot </td>
          <td>(</td>
          <td class="paramtype">T1 *&amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T2::*)(P1, P2, P3, P4, P5, P6)&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloaded slot factory function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>- a reference to a pointer to an object of type T1. </td></tr>
    <tr><td class="paramname">function</td><td>- a class method with the signature R (T2::*function)(P1, P2, P3, P4, P5, P6). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new slot passing six arguments of type P1, P2, P3, P4, P5 and P6, and returning a value of type R.</dd></dl>
<p><br />
T1 can be the same object type as T2. If the returned slot is connected to a signal it doesn't have to be unreferenced. The signal it's connected to will unreference the slot when it is destroyed. Otherwise the slot must be unreferenced by calling unref(). </p>

</div>
</div>
<a class="anchor" id="gae529c1f1a1602338f5d88c6f0fc964c4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename R , typename P1 , typename P2 , typename P3 , typename P4 , typename P5 , typename P6 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Slot6&lt;R, P1, P2, P3, P4, P5, P6&gt;* scim::slot </td>
          <td>(</td>
          <td class="paramtype">T1 *const &amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T2::*)(P1, P2, P3, P4, P5, P6)&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloaded slot factory function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>- a reference to a const pointer to an object of type T1 (e.g. this). </td></tr>
    <tr><td class="paramname">function</td><td>- a class method with the signature R (T2::*function)(P1, P2, P3, P4, P5, P6). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new slot passing six arguments of type P1, P2, P3, P4, P5 and P6, and returning a value of type R.</dd></dl>
<p><br />
T1 can be the same object type as T2. If the returned slot is connected to a signal it doesn't have to be unreferenced. The signal it's connected to will unreference the slot when it is destroyed. Otherwise the slot must be unreferenced by calling unref(). </p>

</div>
</div>
<a class="anchor" id="gab749aaacb506c445b4d62b5f1f484658"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename R , typename P1 , typename P2 , typename P3 , typename P4 , typename P5 , typename P6 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Slot6&lt;R, P1, P2, P3, P4, P5, P6&gt;* scim::slot </td>
          <td>(</td>
          <td class="paramtype">T1 &amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T2::*)(P1, P2, P3, P4, P5, P6)&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloaded slot factory function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>- a reference to an object of type T1. </td></tr>
    <tr><td class="paramname">function</td><td>- a class method with the signature R (T2::*function)(P1, P2, P3, P4, P5, P6). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new slot passing six arguments of type P1, P2, P3, P4, P5 and P6, and returning a value of type R.</dd></dl>
<p><br />
T1 can be the same object type as T2. If the returned slot is connected to a signal it doesn't have to be unreferenced. The signal it's connected to will unreference the slot when it is destroyed. Otherwise the slot must be unreferenced by calling unref(). </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Jun 9 2017 17:00:46 for scim by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.8 </li>
  </ul>
</div>
</body>
</html>
